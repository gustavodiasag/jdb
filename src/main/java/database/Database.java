package main.java.database;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

/*
 * Responsible for managing all operations and
 * manipulations that may occur in the "database".
 */
public class Database {

	/*
	 * Provides the reading and writing operations
	 * in the file specified.
	 */
	private final RandomAccessFile raf;

    public Database(File file) throws IOException {
    	this.raf = new RandomAccessFile(file, "rw");
		this.initialize();
    }
    
    private void initialize() throws IOException {
    	try {
    		Record[] records = CSVParser.parse();
    		
			/*
			 * Storing the highest "id" value before the records is clever
			 * cause this attribute should not be user-defined and new
			 * values are easily generated by incrementation.
			 */
    		int lastId = records[records.length - 1].getId();
    		
    		raf.writeInt(lastId);
    		
    		for (Record record : records)
    			record.serialize(raf);
    		
    	} catch (IOException e) {
    		throw new IOException(
    			"Error while initializing the database", e);
    	}
    }

	/*
	 * Returns the entity with the corresponding "id" value
	 * and null if it isn't found in the database.
	 */
    public Record get(int id) throws IOException {
    	try {
			// Header is not useful for this operation.
    		raf.seek(Integer.BYTES);
    		
    		while (!eof()) {
    			boolean valid = raf.readBoolean();
    			int recordSize = raf.readInt();
    			
    			if (valid) {
    				Record r = Record.deserialize(raf);
    				
    				if (r.getId() == id)
    					return r;
    				
    			} else
					// Deleted records must not be read.
    				raf.skipBytes(recordSize);
    		}
    		
    	} catch (IOException e) {
    		throw new IOException(
				"Error while retrieving record from id: " + id, e);
    	}
    	
    	return null;
    }
    
	/*
	 * Returns true if a new entity is successfuly inserted
	 * into the database and an exception otherwise.
	 */
    public boolean insert(Record record) throws IOException {            
        try {
        	record.setId(getLastId() + 1);
        	
            raf.seek(0);
            raf.writeInt(record.getId());

			// New records are always inserted at the end.
            raf.seek(raf.length());
            record.serialize(raf);

            return true;

        } catch (IOException e) {
            throw new IOException(
				"Unable to insert record record:\n" + record.toString(), e);
        }
    }
    
	/*
	 * Returns true if it was successfuly able to update
	 * such record and false otherwise.
	 */
    public boolean update(Record record) throws IOException {
    	try {
    		raf.seek(Integer.BYTES);
    		
    		while (!eof()) {
    			long pos = raf.getFilePointer();
    			boolean valid = raf.readBoolean();
    			int recordSize = raf.readInt();
    			
    			if (valid) {
    				Record r = Record.deserialize(raf);
    				
    				if (record.getId() == r.getId()) {
    					byte[] recordAsBytes = record.toByteArray();
    					raf.seek(pos);

    					if (recordAsBytes.length <= recordSize)
							record.serialize(raf, recordSize);
						else {
							raf.writeBoolean(false);
							raf.seek(raf.length());

							record.serialize(raf);
						}

						return true;
    				}

    			} else
					raf.skipBytes(recordSize);
    		}
    		
    	} catch (IOException e) {
    		throw new IOException(
    			"Error while updating record with id: " + record.getId(), e);
    	}

		return false;
    }

	/*
	 * Returns true if the record with such "id" is successfully
	 * removed from the "databse", false otherwise.
	 */
    public boolean delete(int id) throws IOException {
        try {
			// Header is not useful for this operation.
            raf.seek(Integer.BYTES);

            while (!eof()) {

				// Position of the validation bit.
                long pos = raf.getFilePointer();
                boolean valid = raf.readBoolean();
                int recordSize = raf.readInt();

                if (valid) {
                    Record r = Record.deserialize(raf);

                    if (r.getId() == id) {
                        raf.seek(pos);
                        raf.writeBoolean(false);

                        return true;
                    }

                } else
					// Deleted records must not be read.
                    raf.skipBytes(recordSize);
            }

        } catch (IOException e) {
            throw new IOException(
            	"Error while deleting record with id: " + id, e);
        }

        return false;
    }
    
	// Returns the first four bytes of the file.
    private int getLastId() throws IOException {
    	try {
    		raf.seek(0);
    		
    		return raf.readInt();
    		
    	} catch (IOException e) {
    		throw new IOException(
    			"Unable to retrieve file header", e);
    	}
    }

	/*
	 * Returns whether there's still an offset between
	 * the file pointer and the file's length.
	 */
    private boolean eof() throws IOException {
        try {
            return raf.getFilePointer() == raf.length();

        } catch (IOException e) {
            throw new IOException(
            	"Error while checking for EOF", e);
        }
    }

	private int foo() {
		return 2;
	}
}
