package main.java.database;

import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;

/*
 * Responsible for managing all operations and
 * manipulations that may occur in the "database".
 */
public class Database implements Sorting {
    /*
     * Provides the reading and writing operations
     * in the file specified.
     */
    private final RandomAccessFile raf;

    public Database(File file) throws IOException {
        this.raf = new RandomAccessFile(file, "rw");
        this.initialize();
    }
    
    private void initialize() throws IOException {
        try {
            Record[] records = CSVParser.parse();
            
            /*
             * Storing the highest "id" value before the records is clever
             * cause this attribute should not be user-defined and new
             * values are easily generated by incrementation.
             */
            int lastId = records[records.length - 1].getId();
            raf.writeInt(lastId);
            
            for (Record record : records)
                record.serialize(raf);
            
        } catch (IOException e) {
            throw new IOException(
                "Error while initializing the database", e);
        }
    }

    /*
     * Returns the entity with the corresponding "id" value
     * and null if it isn't found in the database.
     */
    public Record get(int id) throws IOException {
        try {
            // Header is not useful for this operation.
            raf.seek(Integer.BYTES);
            
            while (!eof(raf)) {
                long pos = raf.getFilePointer();
                boolean valid = raf.readBoolean();
                int recordSize = raf.readInt();
                
                if (valid) {
                    raf.seek(pos);
                    Record r = Record.deserialize(raf);
                    
                    if (r.getId() == id)
                        return r;
                } else
                    // Deleted records must not be read.
                    raf.skipBytes(recordSize);
            }
            
        } catch (IOException e) {
            throw new IOException(
                "Error while retrieving record with id: " + id, e);
        }
        
        return null;
    }
    
    /*
     * Returns true if a new entity is successfully inserted
     * into the database and an exception otherwise.
     */
    public boolean insert(Record record) throws IOException {            
        try {
            record.setId(getLastId() + 1);
            raf.seek(0);
            raf.writeInt(record.getId());

            // New records are always inserted at the end.
            raf.seek(raf.length());
            record.serialize(raf);

            return true;
            
        } catch (IOException e) {
            throw new IOException(
                "Unable to insert record record:\n" + record.toString(), e);
        }
    }
    
    /*
     * Returns true if it was successfully able to update
     * such record and false otherwise.
     */
    public boolean update(Record record) throws IOException {
        try {
            raf.seek(Integer.BYTES);
            
            while (!eof(raf)) {
                long pos = raf.getFilePointer();
                boolean valid = raf.readBoolean();
                int recordSize = raf.readInt();
                
                if (valid) {
                    raf.seek(pos);
                    Record r = Record.deserialize(raf);
                    
                    if (record.getId() == r.getId()) {
                        byte[] recordAsBytes = record.toByteArray();
                        raf.seek(pos);

                        if (recordAsBytes.length <= recordSize)
                            record.serialize(raf, recordSize);
                        else {
                            raf.writeBoolean(false);
                            raf.seek(raf.length());

                            record.serialize(raf);
                        }

                        return true;
                    }

                } else
                    raf.skipBytes(recordSize);
            }
        } catch (IOException e) {
            throw new IOException(
                "Error while updating record with id: " + record.getId(), e);
        }

        return false;
    }

    /*
     * Returns true if the record with such "id" is successfully
     * removed from the "database", false otherwise.
     */
    public boolean delete(int id) throws IOException {
        try {
            // Header is not useful for this operation.
            raf.seek(Integer.BYTES);

            while (!eof(raf)) {
                // Position of the validation bit.
                long pos = raf.getFilePointer();
                boolean valid = raf.readBoolean();
                int recordSize = raf.readInt();

                if (valid) {
                    raf.seek(pos);
                    Record r = Record.deserialize(raf);

                    if (r.getId() == id) {
                        raf.seek(pos);
                        raf.writeBoolean(false);

                        return true;
                    }
                    
                } else
                    // Deleted records must not be read.
                    raf.skipBytes(recordSize);
            }
        } catch (IOException e) {
            throw new IOException(
                "Error while deleting record with id: " + id, e);
        }

        return false;
    }
    
    public void sort(int limit) throws IOException {
        try {
            RandomAccessFile first = new RandomAccessFile("tmp1", "rw");
            RandomAccessFile second = new RandomAccessFile("tmp2", "rw");
            raf.seek(Integer.BYTES);
            
            while (!eof(raf)) {
                sort(first, limit);
                sort(second, limit);
            }
            
            intercalate(first, second, limit);
            
        } catch (IOException e) {
            throw new IOException("Unable to sort", e);
        }
    }
    
    private void sort(RandomAccessFile tmp, int limit) throws IOException {
        try {
            Record[] records = new Record[limit];
            
            int i = 0;
            for (; !eof(raf) && i < limit; i++)
                records[i] = Record.deserialize(raf);
            
            /*
             * This notation guarantees that the sorting operation
             * will only consider existing objects.
             */
            quickSort(records, 0, i-1);
            
            for (Record record : records)
                if (record != null) 
                    record.serialize(tmp);
            
        } catch (IOException e) {
            throw new IOException("Error while sorting", e);
        }
    }
    
    private void intercalate(RandomAccessFile first, RandomAccessFile second, int limit)
        throws IOException {
        
        try {
            first.seek(0);
            second.seek(0);
            
            RandomAccessFile third = new RandomAccessFile("tmp3", "rw");
            RandomAccessFile fourth = new RandomAccessFile("tmp4", "rw");
            
            Record firstRecord, secondRecord;
            
            while (!eof(first) && !eof(second)) {
                long firstPos = first.getFilePointer();
                long secondPos = second.getFilePointer();
                
                firstRecord = Record.deserialize(first);
                secondRecord = Record.deserialize(second);
                
                if (firstRecord.getEpisodes() < secondRecord.getEpisodes()) {
                    firstRecord.serialize(third);
                    second.seek(secondPos);
                    
                } else {
                    secondRecord.serialize(fourth);
                }
            }
            
        } catch (IOException e) {
            throw new IOException("Error while intercalating ", e);
        }
    }
    
    // Returns the file's first four bytes.
    private int getLastId() throws IOException {
        try {
            raf.seek(0);
            
            return raf.readInt();
            
        } catch (IOException e) {
            throw new IOException(
                "Unable to retrieve file header", e);
        }
    }

    /*
     * Returns whether there's still an offset between
     * the file pointer and the file's length.
     */
    private boolean eof(RandomAccessFile raf) throws IOException {
        try {
            return raf.getFilePointer() == raf.length();

        } catch (IOException e) {
            throw new IOException(
                "Error while checking for EOF", e);
        }
    }
}
